'''
    Contains the functions to set up the map visualization.

'''

#from turtle import width, window_height, window_width
# from attr import dataclass
import plotly.graph_objects as go
import plotly.express as px



def get_map(data,type,lim=0,last_zoom=None,prev_scale=None):
    """
    Create the map figure on "Arrival" or "Departure" trafic.

        Args:
            data: data of harbour trafic filter on "Arrival" or "Departure"
            type: "Arrival" or "Departure" trafic to show
            lim: minimal number of trafic for each harbour to be shown
            last_zoom: parameter data on last zoom apply to the map, we apply it on uptaded figure so the map is not reset on every updates
        Returns:
            fig: The updated figure 
    
    """
    #filtre des données sur la limite de trafic
    data = data[data["Trafic"]>=lim]

    #création de la figure "Departure" or "Arrival"
    fig = px.scatter_geo(data, lat=type+" Latitude", lon=type+" Longitude",text= type+" Hardour", 
  color=data["Trafic"])

    
    fig.update_geos(
        resolution=50,
        showcoastlines=True, coastlinecolor="RebeccaPurple",
        showland=True, 
        showocean=True, oceancolor="LightBlue",
        showlakes=True, lakecolor="LightBlue",
        showrivers=True,
        showcountries=True, countrycolor="Black",
        showsubunits=True, subunitcolor="Grey",
        #center=dict(lon=-100, lat=48),
        projection_type="mercator"
        #lataxis_range=[50,85], lonaxis_range=[-60, -40]
        #,fitbounds="locations"
        #,framewidth=12
    )
#https://plotly.com/python/reference/layout/geo/#layout-geo-uirevision
    fig.update_coloraxes(showscale=False)
  

    #conservation des paramètres de zoom précédent 
    # TODO: reste à conserver la taille de la carte, comment la fixer ?
    #https://dash.gallery/dash-uber-rides-demo/

    if last_zoom != None:
        keys = last_zoom.keys()
        if 'geo.projection.rotation.lon' in keys:
            fig.update_geos(
                projection_rotation_lon = float(last_zoom['geo.projection.rotation.lon'])
            )
        if 'geo.projection.rotation.lat' in keys:
            fig.update_geos(
                projection_rotation_lat = float(last_zoom['geo.projection.rotation.lat'])
            )
        if 'geo.projection.rotation.roll' in keys:
            fig.update_geos(
                projection_rotation_roll = float(last_zoom['geo.projection.rotation.roll'])
            )
        if 'geo.projection.scale' in keys:
            fig.update_geos(
                projection_scale = float(last_zoom['geo.projection.scale'])
            )
        else:
            if prev_scale != None:
                fig.update_geos(
                    projection_scale = float(prev_scale)
            )

        if 'geo.center.lon' in keys:
            fig.update_geos(
                center_lon = float(last_zoom['geo.center.lon'])
            )
        if 'geo.center.lat' in keys:
            fig.update_geos(
                center_lat = float(last_zoom['geo.center.lat'])
            )
                 

    fig.update_traces(marker=dict(size=9))

    fig.update_layout(
        # width=1000,
        # height=500,
        margin={"r": 0, "t": 0, "l": 0, "b": 0, "pad":0 , "autoexpand":True},
        # autosize=False,
        mapbox_center=go.layout.mapbox.Center(
        lat=48,
        lon=-100),
        #min_zoom=1.3
    )

       
            
    #faire en sorte qu'il n'y ait pas de superposition de points

    return fig




def get_barchart(data,type,lim=0):

    data_graph = data[data["Trafic"]>lim]
    data_graph = data_graph.sort_values("Trafic", ascending=True)

    fig = go.Figure(
        data=[go.Bar(
            x=data_graph["Trafic"],
            y= data_graph[type+" Hardour"],
            orientation="h",
            #width=5,
            base="overlay",
            

            )]
        )

    fig.update_layout(
        bargap=0.5,
        # width=300,
        #height=400,
        margin={"r": 0, "t": 20, "l": 200, "b": 0, "pad":4 , "autoexpand":True},

        xaxis_anchor="free",
        xaxis_position=1,
        yaxis_automargin=True,
        xaxis_autorange=True
    
    )


    return fig

"""

 fig = px.bar(data,y=type+" Hardour",x="Trafic",orientation="h")

"""